大課題3実施手順備忘録


awsインスタンス作成 (dive20-2参照)
13.112.120.169

macローカル環境構築抜け漏れチェック(dive10)


railsをインストール
 gem install rails -v 4.2.3

railsアプリのインストール データベースはポスグレ
 rails _4.2.3_ new daikadai3 -d postgresql


ブートストラップのインストール
 gem 'twitter-bootstrap-rails'


# githubの設定

git init

gitgub側でリポジトリを作る
git remote -a git@github.com:skykataoka/daikadai3.git


# herokuの設定

herokuでリポジトリを作る

heroku login
heroku git:remote -a daikadai3



# ※いったんモデル・関係図を整理したほうがいいな。



  まずモデルからいいらしい
    rails g model topic

  順序としては
  User (devise使う)
  Topic
  Comment
  Relationship
  Conversation
  Message


## User
  gemにdeviseを入れてバンドルインストール

  rails generate devise:install
  rails generate devise user

  マイグレーションファイルに下記追記

      ## SNSログイン
      t.string :name
      t.string :snsid, null: false, default: ""
      t.string :snstype, null: false, default: ""
      t.string :image_url

      ↓他のadd_indexと並んでるところにあとで入れる。
      add_index :users, [:snsid, :snstype], unique: true



      rake db:migrate



## Topic
  rails g model topic

  マイグレーションファイルに下記追記
    t.references :user, foreign_key: true
    t.string :title
    t.text :content

      rake db:migrate

  アソシエーションを設定
    topicモデル ⇒ belongs_to :user
    userモデル ⇒ has_many :blogs

## Comment
  rails g model comment

    マイグレーションファイルに下記追記
    t.references :topic ,foreign_key: true
    t.text :content


    rake db:migrate


  アソシエーションを設定
    userモデル ⇒ has_many :topics, dependent: :destroy      ←上書き
                  has_many :comments, dependent: :destroy

    topicモデル ⇒ has_many :comments, dependent: :destroy

    commentモデル⇒ belongs_to :user
                    belongs_to :topic


  ※親のモデルtopicだけでなく、その親のuserモデルにも設定するのが肝


    URLはtopicと紐付くので入れ子にする。routesを設定
      resources :topics do
        resources :comments
      end


## Rerationship
  rails g model rerationship

    マイグレーションファイルに下記追記
      t.integer :follower_id
      t.integer :followed_id
    end
    add_index :relationships, :follower_id
    add_index :relationships, :followed_id
    add_index :relationships, [:follower_id, :followed_id], unique: true

        rake db:migrate


    アソシエーションを設定

    Userモデル ⇒   has_many :relationships, foreign_key: "follower_id", dependent: :destroy
                    has_many :reverse_relationships, foreign_key: "followed_id", class_name: "Relationship", dependent: :destroy
                              ↑任意の名前でOK わかりやすくするために1つめのと分けた             ↑このモデルに紐つくことを明示

    Relationshipモデル ⇒    belongs_to :follower, class_name: "User"
                             belongs_to :followed, class_name: "User"
                              ↑どちらもUserテーブルにbelongs_to してますが,ひもついてるカラムが違う(user_idではない)のでこのように標記。

    # Userモデルがrelationshipsモデルを通じて複数のUserを所持することを定義
    Userモデル ⇒      has_many :followed_users, through: :relationships, source: :followed
                       has_many :followers, through: :reverse_relationships, source: :follower


## Conversation

    ルーティングの設定
    resources :conversations do
      resources :messages
    end

    モデルの作成
    rails g model conversation

      t.integer :sender_id
      t.integer :receiver_id

    アソシエーションの設定

    Conversationモデル ⇒   belongs_to :sender, foreign_key: :sender_id, class_name: 'User'
                            belongs_to :receiver, foreign_key: :receiver_id, class_name: 'User'

    Userモデル ⇒  has_many :senders, foreign_key: "sender_id", dependent: :destroy, class_name: "Conversation"
                   has_many :receivers, foreign_key: "receiver_id", dependent: :destroy, class_name: "Conversation"


## Message

    モデルの作成
    rails g model message body:text conversation:references user:references read:boolean

    t.boolean :read, default: false   ##←初期状態で未読と登録する
    とすること。


    Conversationモデル ⇒   has_many :messages, dependent: :destroy

    Userモデル ⇒  has_many :messages, dependent: :destroy

    Messsage ⇒   belongs_to :conversation
                  belongs_to :user, dependent: :destroy



# 基本となるtopicコントローラーをつくろう

   ## topicsコントローラー

   rails g controller index new


  newの画面でpostするとcreateが走る
  パラーメーターという箱がある
  パラメーターの中身を利用するためには関数を専用に設定する必要がある⇒ストロングパラメーター


  redirect_toの利用例
  redirect_to :action => "show" # showアクションにリダイレクト
  redirect_to 'http://diveintocode.jp/' # diveintocode.jpページにリダイレクト
  redirect_to controller: :blogs, action: :new #blogsコントローラのnewアクションにリダイレクト

  まずindex new createをつくる。

  次にedit updateをつくり

  destroy
  detoroyメソッドはupdateと違ってパラメーターは不要
  例 @topic.update(ストロングパラメーター)
     @topic.destroy(ストロングパラメーター)


  最後showを作る
  editと似ている


  noteiceメソッドでボタンを押したときに通知ができる


  バリデーションを設定する

  topicモデルに下記を追記 titleカラムが空の値で登録されるのを防ぐ
   validates :title, presence: true


  # トップページが　topics/indexになるようにする
  root 'topics#index'


# ブートストラップインストール

  gem 'twitter-bootstrap-rails'
  でバンドルインストールした後

  rails generate bootstrap:install static



# ユーザーログイン機能を追加する

  rails generate devise:views
  で必要なviewを用意する。

  日本語化する
  config/application.rb
  の
  # config.i18n.default_locale = :de
  ↓
  config.i18n.default_locale = :ja


  そしてconfig/locales/devise.ja.ymlファイルを作って
  https://gist.github.com/kaorumori/7276cec9c2d15940a3d93c6fc
  の内容をコピー

  他DIVE8の内容に沿って最適化

  ## アプリケーションコントローラーで下記内容を追記。
  nameカラムが新規登録とアカウント更新の際に、パラメータに含まれるようする。

    # before_actionで下で定義したメソッドを実行
    before_action :configure_permitted_parameters, if: :devise_controller?

    #変数PERMISSIBLE_ATTRIBUTESに配列[:name]を代入
    PERMISSIBLE_ATTRIBUTES = %i(name)

    protected

      #deviseのストロングパラメーターにカラム追加するメソッドを定義
      def configure_permitted_parameters
        devise_parameter_sanitizer.permit(:sign_up, keys: PERMISSIBLE_ATTRIBUTES)
        devise_parameter_sanitizer.permit(:account_update, keys: PERMISSIBLE_ATTRIBUTES)
      end

  ## ログインユーザーidが topicテーブルのuser_idに保存されるようにする。

  topics_controller

  def create
    Blog.create(blogs_params)
    @topic.user_id = current_user.id
  end



#  メーラーの設定
    gem 'letter_opener_web' を入れて諸々設定を行う

    config/routes に下記設定を追記
    if Rails.env.development?
      mount LetterOpenerWeb::Engine, at: "/letter_opener"
    end

    本番環境用のメール設定はひとまずheroku

   環境変数でidパスワードを入れたほうが良いので
   gem 'dotenv-rails'

   .envの設定


   rails g mailer NoticeMailer sendmail_blog


   もろもろ・・・詳細はdive11参照

  ## Mailerを呼び出すためのアクションを設定する

  topiccontrollerを下記のように書き換える。


    def create
      @topic = Topic.new(topics_params)  ## 元々 Topic.create(topics_params) だった
      @topic.user_id = current_user.id  ## 現在ログインしているユーザーidがuser_idカラムに保存されるようにする。
      if @topic.save
        redirect_to topics_path, notice: "ブログを作成しました！"
        NoticeMailer.sendmail_topic(@topic).deliver
      else
        render 'new'
      end
    end

  Userモデルのdevise欄に
    :confirmable
    を追加


  rails g migration AddConfirmableToDevise

  できたマイグレーションファイルに下記を追記

  class AddConfirmableToDevise < ActiveRecord::Migration
  def up
    add_column :users, :confirmation_token, :string
    add_column :users, :confirmed_at, :datetime
    add_column :users, :confirmation_sent_at, :datetime
    add_column :users, :unconfirmed_email, :string
    add_index :users, :confirmation_token, unique: true
    # User.reset_column_information # Need for some types of updates, but not for update_all.

    execute("UPDATE users SET confirmed_at = NOW()")
  end

  def down
    remove_columns :users, :confirmation_token, :confirmed_at, :confirmation_sent_at
    remove_columns :users, :unconfirmed_email # Only if using reconfirmable
  end
end


rake db:migrate

  ※今まで適当にブログやuserデータを複数作成していた場合は消去したほうが良い
   例 User.delete_all


# SNSログイン

 Oauthの実装
  Userモデルに devise ::omniauthable を追加

  ルーティングファイルに下記追加
      devise_for :users, controllers: {
        omniauth_callbacks: "users/omniauth_callbacks"
       }

facebookアプリのIDとPASS
    production  ID:336695293399902    PASS:d3e8979a61084d1b8440f38ed348528e
    develop     ID:1830042413679993   PASS:d52f942be4799c91c7803fe6582e35dd
      テスト    ID:1830050773679157   PASS:b20a744809d861e22889422b7288c7cc

twitterアプリ
    production    Consumer Key (API Key)  o2gtw79WMb1QOBBMMkzJCAal5
                  Consumer Secret (API Secret)  T2aGp87M0HZPtCP61mZBLBAjvS2m1L2mHzum4UoXb8YSSQiZup


    develop   Consumer Key (API Key)  7tYxLuZjiZSgvBL7yFUNE4hGR
              Consumer Secret (API Secret)  G2UDoron5bABnzjr2sDAaEpIJEmNZKGtA1Q1zgXSlXExBX82Zi

config/initializers/devise.rb
    if Rails.env.production?
      config.omniauth :facebook, ENV["FACEBOOK_ID_PRODUCTION"], ENV["FACEBOOK_SECRET_PRODUCTION"], scope: 'email', display: 'popup', info_fields: 'name, email'
      config.omniauth :twitter, ENV["TWITTER_ID_PRODUCTION"], ENV["TWITTER_SECRET_PRODUCTION"], scope: 'email', display: 'popup', info_fields: 'name, email'
    else
      config.omniauth :facebook, ENV["FACEBOOK_ID_DEVELOPMENT"], ENV["FACEBOOK_SECRET_DEVELOPMENT"], scope: 'email', display: 'popup', info_fields: 'name, email'
      config.omniauth :twitter, ENV["TWITTER_ID_DEVELOPMENT"], ENV["TWITTER_SECRET_DEVELOPMENT"], scope: 'email', display: 'popup', info_fields: 'name, email'
    end

  .envファイルに追記
  FACEBOOK_ID_PRODUCTION=336695293399902
  FACEBOOK_SECRET_PRODUCTION=d3e8979a61084d1b8440f38ed348528e
  TWITTER_ID_PRODUCTION=o2gtw79WMb1QOBBMMkzJCAal5
  TWITTER_SECRET_PRODUCTION=G2UDoron5bABnzjr2sDAaEpIJEmNZKGtA1Q1zgXSlXExBX82Zi

  FACEBOOK_ID_DEVELOPMENT=1830042413679993
  FACEBOOK_SECRET_DEVELOPMENT=d52f942be4799c91c7803fe6582e35dd
  TWITTER_ID_DEVELOPMENT=7tYxLuZjiZSgvBL7yFUNE4hGR
  TWITTER_SECRET_DEVELOPMENT=G2UDoron5bABnzjr2sDAaEpIJEmNZKGtA1Q1zgXSlXExBX82Zi

  Omniauthのインストール
    Gemfile
      gem 'omniauth'
      gem 'omniauth-twitter'
      gem 'omniauth-facebook'


  カラムの追加
  rails g migration AddOmniauthColumnsToUsers

  def change
    add_column :users, :snsid, :string, null: false, default: ""      ##←追加してたら不要
    add_column :users, :snstype, :string, null: false, default: ""    ##←追加してたら不要
    add_column :users, :image_url, :string                            ##←追加してたら不要

    add_index :users, [:snsid, :snstype], unique: true
  end

  rake db:migrate か rake db:migrate:reset

  ## facebook と twitterのアクションを作成する
    mkdir app/controllers/users

    rails g controller users::OmniauthCallbacks

    OmniauthCallbacksControllerの継承元をApplicationControllerからDeviseのコールバックコントローラへ書き換える
    場所 app/controllers/users/omniauth_callbacks_controller.rb
      class Users::OmniauthCallbacksController < Devise::OmniauthCallbacksController
      end


    ### facebookアクションへの実装
      コントローラーへの詳細

      class Users::OmniauthCallbacksController < Devise::OmniauthCallbacksController
        def facebook
          @user = User.find_for_facebook_oauth(request.env["omniauth.auth"], current_user)

          if @user.persisted?
            set_flash_message(:notice, :success, kind: "Facebook") if is_navigational_format?
            sign_in_and_redirect @user, event: :authentication
          else
            session["devise.facebook_data"] = request.env["omniauth.auth"]
            redirect_to new_user_registration_url
          end
        end
      end


      Userモデルへの記載
      class User < ActiveRecord::Base
        省略
          def self.find_for_facebook_oauth(auth, signed_in_resource=nil)
            user = User.find_by(email: auth.info.email)

            unless user
              user = User.new(
                  name:     auth.extra.raw_info.name,
                  snstype: auth.provider,
                  snsid:      auth.uid,
                  email:    auth.info.email ||= "#{auth.uid}-#{auth.provider}@example.com",
                  image_url:   auth.info.image,
                  password: Devise.friendly_token[0, 20]
              )
              user.skip_confirmation!
              user.save(validate: false)
            end
            user
          end
        end

        ### twitterも同様に行う

    ## 新規登録機能も修正

      hash[:uid] = User.create_unique_string

      rails g controller users::registrations

      場所 app/controllers/users/registrations_controller.rb

        class Users::RegistrationsController < Devise::RegistrationsController
          def build_resource(hash=nil)
            hash[:snsid] = User.create_unique_string
            super
          end
        end

    ##　ランダムにsnsidを作成するメソッドを追加

    場所 app/models/user.rb

    def self.create_unique_string
        SecureRandom.uuid
    end


    ※uuidメソッドを使うことでランダムな文字列が作れる

    ## ルーティングで新規登録時に継承したregistration_controllerに飛ぶようにする。
    場所 config/routes.rb

        devise_for :users, controllers: {
            registrations: "users/registrations",       ##←ここを追加
            omniauth_callbacks: "users/omniauth_callbacks"
        }


#プロフィール画像の表示
    場所 app/helpers/application_helper.rb

    module ApplicationHelper
    でuserの画像を表示させるヘルパーを定義。

      # 省略
      def profile_img(user)
        unless user.provider.blank?
          img_url = user.image_url
        else
          img_url = 'no_image.png'
        end
        image_tag(img_url, alt: user.name)
      end
      # 省略
    end


    ## noimage画像を登録

    Gemfile
      gem 'carrierwave'
      gem 'rmagick'

    $ brew update

    $ brew install imagemagick

    うまくバンドルインストールできないときは
    これを行う。
      $brew unlink imagemagick
      $brew uninstall imagemagick
      $brew install imagemagick@6
      $brew link imagemagick@6 --force
      $sudo gem install rmagick

    ## carrierwaveの初期設定を行う。
      rails generate uploader Avatar

      画像を保存するためのカラムを追加。 (avator→SNSなしの人用 image_url→SNSの画像)
      rails g migration add_avatar_to_users avatar:string

      rake db:migrate

    ## モデルにキャリアウェーブ用の設定を行う
      場所 app/models/user.rb

       mount_uploader :avatar, AvatarUploader #deviseの設定配下に追記

    ## ユーザー編集ページで画像をアップロードできるようにする
      場所 app/controllers/application_controller.rb
       PERMISSIBLE_ATTRIBUTES = %i(name avatar avatar_cache)

      場所 app/views/devise/registations/edit.html.erb
       に下記コードを追加
        <div class="field">
          <%= profile_img(@user) if profile_img(@user) %>
          <%= f.file_field :avatar %>
          <%= f.hidden_field :avatar_cache %>
        </div>

    ## 定義したヘルパーメソッドにキャリアウェーブでUPした画像を表示させるようにする。
      場所 app/helpers/application_helper.rb
        def profile_img(user)
          return image_tag(user.avatar, alt: user.name) if user.avatar? ←追加。

          unless user.provider.blank?
            img_url = user.image_url
          else
            img_url = 'no_image.png'
          end
          image_tag(img_url, alt: user.name)
        end

        プログラムの構造としては、
        第1優先→マイページでUPした画像
        第2優先→SNSから引っ張ってきた画像
        第3優先→asset内のno_image.png

    ## SNSログインした人もユーザー情報を編集できるようにする。
      場所 app/models/user.rb

        def update_with_password(params, *options)
          if snstype.blank?   ## SNSログインじゃなけりゃそのまま通常通り
            super
          else                 ## SNSログインの方はパスワード不要で更新OK
            params.delete :current_password
            update_without_password(params, *options)
          end
        end


    ## SNSログインした人はview画面でパスワード関連項目が非表示になるようにする。
      パスワード関連項目を下記で囲む
        <% if @user.snstype.blank? %>


        <% end %>



# コメント機能の実装
    builtメソッド
    respond_to メソッド
    押さえとく

    rails g controller Comments create


    ## topics_controller のindexを変更する

    def index
      @topics = Topic.all
      respond_to do |format|
        format.html ##←HTMLのリクエスト
        format.js   ##←JavaScriptのリクエスト
      end
    end

    ## comments_controller.rb を設定
     # コメントを保存、投稿するためのアクションです。
        def create
          # Blogをパラメータの値から探し出し,Blogに紐づくcommentsとしてbuildします。
          @comment = current_user.comments.build(comment_params)
          @blog = @comment.blog
          # クライアント要求に応じてフォーマットを変更
          respond_to do |format|
            if @comment.save
              format.html { redirect_to blog_path(@blog), notice: 'コメントを投稿しました。' }
            else
              format.html { render :new }
            end
          end
        end

        private
          # ストロングパラメーター
          def comment_params
            params.require(:comment).permit(:blog_id, :content)
          end


    ## topics_controller.rb を設定

      def show
        @topic = Topic.find(params[:id])
        @comment = @topic.comments.build ←追加
        @comments = @topic.comments      ←追加
      end



    ## topic のshow画面にcommentの一覧・入力フォームを作る。
        長いのでDIVE15テキスト参照

        renderを2つ使うのがポイント
          renderする際は 値を渡す必要がある。
          例:  <%= render partial: 'comments/index', locals: { comments: @comments, blog: @blog } %>



          %>

    ## format.js { render :index }の内容を書く
      場所: app/views/comments/index.js.erb   を作成

      $("#comments_area").html("<%= j(render 'comments/index', { comments: @comment.topic.comments, topic: @comment.topic }) %>")
      $(':text').val('')

      id="comments_area" で指定した場所が変わる
      コメント欄が空欄になる

    ## delete機能の実装


# フォロー機能の実装

  ## ユーザー一覧ページの作成
    usersコントローラーを作る
      rails g controller users index

      def index
        @users = User.all
      end



    ルーティングの設定
      resources :users, only: [:index]

    viewの設定
    場所 app/views/users/index.html.erb

      <div class="container">
        <h2>ユーザー</h2>
        <% @users.each do |user| %>
            <div class="container-child col-md-2 col-sm-4 col-xs-6 ">
              <%= profile_img(user) %>      ←定義したヘルパー
              <%= user.email %>
              <%= render 'follow_form', user: user %>  ←ファクタリングで設定した画面にジャンプ
            </div>
        <% end %>
      </div>


  ## follow機能を作成する
    ルーティングの作成
      resources :relationships, only: [:create, :destroy]

    コントローラーの作成
      rails g controller Relationships create destroy     ##←へー専用につくるんだー!という発見!&不要なrootsを削除


          class RelationshipsController < ApplicationController
            before_action :authenticate_user!
            respond_to :js

            def create
              @user = User.find(params[:relationship][:followed_id])
              current_user.follow!(@user)      ##←この!って何??
              respond_with @user
            end
          end


    viewへの反映

      場所 app/views/users/_follow_form.html.erb    ←新しく作る
         <div id="follow_form_<%= user.id %>">
          <% unless current_user.following?(user) %>
            <%= form_for(current_user.relationships.build(followed_id: user.id), remote: true) do |f| %>
              <%= f.hidden_field :followed_id %>
              <%= f.submit "フォロー", class: "btn btn-large btn-primary" %>
            <% end %>
          <% else %>
            <%= form_for(current_user.relationships.find_by(followed_id: user.id), html: { method: :delete }, remote: true) do |f| %>
              <%= f.submit "つながりを解除", class: "btn btn-large" %>
            <% end %>
          <% end %>
        </div>


      <div id="follow_form_<%= user.id %>">としているのは、ユーザー毎にajaxを適用させるため。


      場所 app/views/users/index.html.erb

    コントローラーにクリエイトメソッドを実装する
      class RelationshipsController < ApplicationController
        before_action :authenticate_user!
        respond_to :js

        def create
          @user = User.find(params[:relationship][:followed_id])
          current_user.follow!(@user)
          respond_with @user
        end
      end


    モデルに 専用メソッドを定義
    場所 app/models/user.rb
      省略
        #指定のユーザをフォローする
        def follow!(other_user)
          relationships.create!(followed_id: other_user.id)
        end

        #フォローしているかどうかを確認する
        def following?(other_user)
          relationships.find_by(followed_id: other_user.id)
        end
      省略

    ajaxの実装
      app/views/relationship/create.js.erb

      $("#follow_form_"+"<%= @user.id %>").html("<%= escape_javascript(render partial: 'users/follow_form', locals: { user: @user } ) %>")


  ## フォロー解除機能の設定
  コントローラーにdestroyを実装

    場所 app/controllers/relationships_controller.rb

      def destroy
        @user = Relationship.find(params[:id]).followed
        current_user.unfollow!(@user)
        respond_with @user
      end

  detroy専用のメソッドをuserモデルに定義
    場所 app/models/user.rb

    #指定のユーザのフォローを解除する
      def unfollow!(other_user)
        relationships.find_by(followed_id: other_user.id).destroy
      end

  フォロー解除のAjax処理を実装する
    場所 app/views/relationships/destroy.js.erb
    $("#follow_form_"+"<%= @user.id %>").html("<%= escape_javascript(render partial: 'users/follow_form', locals: { user: @user } ) %>")


#メッセージ機能の実装
  会話コントローラー作成
    rails g controller Conversations index create
    不要なルーティング削除


    before_action :authenticate_user!
        def index
          @users = User.all   ##←ここも必要なのかー。
          @conversations = Conversation.all
        end

        def create
          if Conversation.between(params[:sender_id], params[:receiver_id]).present?      ←もし会話がすでに存在しているなら
            @conversation = Conversation.between(params[:sender_id], params[:receiver_id]).first  ←既にある会話レコードのデータをインスタンス化
          else
            @conversation = Conversation.create!(conversation_params)
          end

          redirect_to conversation_messages_path(@conversation)
        end


        private
          def conversation_params
            params.permit(:sender_id, :receiver_id)
          end

  Conversationモデルにメッソドを定義

      validates_uniqueness_of :sender_id, scope: :receiver_id
      scope :between, -> (sender_id,receiver_id) do
        where("(conversations.sender_id = ? AND conversations.recipient_id =?) OR (conversations.sender_id = ? AND  conversations.recipient_id =?)", sender_id,receiver_id, receiver_id, sender_id)
      end

      def target_user(current_user)
          if sender_id == current_user.id
            User.find(receiver_id)
          elsif receiver_id == current_user.id
            User.find(sender_id)
          end
        end
      end

  メッセージコントローラー作成

      before_action do
        @conversation = Conversation.find(params[:conversation_id])
      end

  readカラムの初期設定が抜けてたので追加

  マイグレーションファイルに下記を入れて、rake db:migrate

    change_column :messages, :read, :boolean, default: false


  ビューの設定
   場所 app/views/conversations/index.html.erb

    <div class="wrapper col-md-6 col-md-offset-3 col-sm-10 col-sm-offset-1">
      <table class="table table-hover">
        <thead>
          <h2>メッセージ一覧</h2>
        </thead>
        <tbody>
          <% @conversations.each do |conversation| %>
            <td>
              <% if conversation.target_user(current_user).present? %>
                <%= link_to conversation.target_user(current_user).name, conversation_messages_path(conversation)%>
              <% end %>
            </td>
          <% end %>
        </tbody>
      </table>
    </div>


    場所  app/views/users/index.html.erb

        <% if user.id != current_user.id %>
      <li>
        <div class="item">
          <%= link_to user.name, user %>
          <%= link_to 'メッセージ', conversations_path(sender_id: current_user.id, receiver_id: user.id), method: 'post'%>
        </div>
        <%= render partial: 'follow_form', locals: { user: user } if signed_in?   %>
      </li>
    <% end %>


AWSデプロイ

  ssh -i achieve-key.pem app@13.112.120.169


  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFy3os046RGn38wVoLmFsXwvndX47/i7MLImKfq7VenZEXrnU2eQ9/ARO/aZU3mK8gfAlmArzZ/yAdHmotrShc9QJgMrMO6j8UcRCegAAVZthPAfzwoYSKmESm86gHjEu43tLNHoCUXUuEdOEmRnNaWL9vsS3Aud6DzPVbfAY+Qc5/magNyDcKSvTjUs3ZIkRfAJ8npjr7DiIJH6wLpsXNLeqEArGmKTa8v7kgdwSR8QQFXy9P6KgUtxgTK4aCsiS63UVWlxYTJ+TkQsvXTTCXaDA7pfrETJtfjXmAZrp1zXCsXq9sRP37d/0Nph5d5wcx/BIAy9cqqOaNcFwio5JN app@ip-172-31-27-164
